//This file was generated by Finch.

/*
This is an example for Poisson, Dirichlet bc.
*/
#include "TreeNode.h"
#include "mpi.h"
#include "genPts_par.h"
#include "sfcSort.h"
#include "mesh.h"
#include "dendro.h"
#include "dendroIO.h"
#include "octUtils.h"
#include "functional"
#include "fdCoefficient.h"
#include "stencil.h"
#include "rkTransport.h"
#include "refel.h"
#include "operators.h"
#include "cg.h"

#include "Genfunction.h"
#include "linear_skel.h"
#include "bilinear_skel.h"

int main (int argc, char** argv)
{

    MPI_Init(&argc, &argv);
    MPI_Comm comm = MPI_COMM_WORLD;

    int rank, npes;
    MPI_Comm_rank(comm, &rank);
    MPI_Comm_size(comm, &npes);
    
    m_uiMaxDepth = 4; // a default value, but should be set in config.cpp
    
    //////////////will be generated/////////////////////////////////////////////
    #include "Config.cpp"
    ////////////////////////////////////////////////////////////////////////////
    
    Point domain_min(0,0,0);
    Point domain_max(1,1,1);
    
    Point grid_min(0, 0, 0);
    Point grid_max((1u << m_uiMaxDepth), (1u << m_uiMaxDepth), (1u << m_uiMaxDepth));
    
    double Rg_x=(grid_max.x()-grid_min.x());
    double Rg_y=(grid_max.y()-grid_min.y());
    double Rg_z=(grid_max.z()-grid_min.z());

    double Rd_x=(domain_max.x()-domain_min.x());
    double Rd_y=(domain_max.y()-domain_min.y());
    double Rd_z=(domain_max.z()-domain_min.z());

    const Point d_min=domain_min;
    const Point d_max=domain_max;

    const Point g_min=grid_min;
    const Point g_max=grid_max;
    
    std::function<double(double)> gridX_to_X = [d_min,g_min,Rd_x,Rg_x](const double x){
        return d_min.x() + (x-g_min.x())*Rd_x/Rg_x;
    };
    
    std::function<double(double)> gridY_to_Y = [d_min,g_min,Rd_y,Rg_y](const double y){
        return d_min.y() + (y-g_min.y())*Rd_y/Rg_y;
    };
    
    std::function<double(double)> gridZ_to_Z = [d_min,g_min,Rd_z,Rg_z](const double z){
        return d_min.z() + (z-g_min.z())*Rd_z/Rg_z;
    };
    
    std::function<void(double,double,double,double*)> zero_init = [](const double x,const double y,const double z,double *var){
        var[0]=0;
    };
    
    set_grid_funs(gridX_to_X, gridY_to_Y, gridZ_to_Z);
    
    //////////////will be generated/////////////////////////////////////////////
    #include "Problem.cpp"
    /////////////////////////////////////////////////////////////////////////////
    
    // Uncomment to display various parameters
    if (!rank) {
    //     std::cout << YLW << "maxDepth: " << m_uiMaxDepth << NRM << std::endl;
    //     std::cout << YLW << "wavelet_tol: " << wavelet_tol << NRM << std::endl;
    //     std::cout << YLW << "partition_tol: " << partition_tol << NRM << std::endl;
    //     std::cout << YLW << "eleOrder: " << eOrder << NRM << std::endl;
    }

    _InitializeHcurve(m_uiDim);
    RefElement refEl(m_uiDim,eOrder);
    
    // This is the tricky part. Octree generation could be based on a function or other variable. This will need to be generated.
    // But for now just use this
    ot::DA* octDA=new ot::DA(f_rhs,1,comm,eOrder,wavelet_tol,100,partition_tol,ot::FEM_CG);
    
    // Variable info will also be generated, but for now assume a single scalar variable
    std::vector<double> uSolVec;
    octDA->createVector(uSolVec,false,false,DOF);
    double *uSolVecPtr=&(*(uSolVec.begin()));

    FinchDendroSkeleton::LHSMat lhsMat(octDA,1);
    lhsMat.setProblemDimensions(domain_min,domain_max);

    FinchDendroSkeleton::RHSVec rhsVec(octDA,1);
    rhsVec.setProblemDimensions(domain_min,domain_max);
    
    // This assumes some things
    lhsMat.setBdryFunction(bc_u_1);
    rhsVec.setBdryFunction(bc_u_1);
    
    double * ux=octDA->getVecPointerToDof(uSolVecPtr,VAR::M_UI_U, false,false); // solution
    double * frhs=octDA->getVecPointerToDof(uSolVecPtr,VAR::M_UI_F, false,false); // rhs function values
    double * Lfrhs=octDA->getVecPointerToDof(uSolVecPtr,VAR::M_UI_LF, false,false); // linear op applied to frhs
    
    octDA->setVectorByFunction(ux,zero_init,false,false,1); // init with zeros
    octDA->setVectorByFunction(Lfrhs,zero_init,false,false,1); // zeros
    octDA->setVectorByFunction(frhs,f_rhs,false,false,1); // set f values
    
    // This uses the generated RHS code to compute the RHS vector. In this case, Lfrhs
    // frhs is used as an input, but in general we will need something more sophisticated
    // to handle complicated RHS expressions
    rhsVec.computeVec(frhs,Lfrhs,1.0);
    
    // Solve the linear system. 
    // For time dependent problems this will need to be in a loop along with a few other pieces.
    lhsMat.cgSolve(ux,Lfrhs,solve_max_iters,solve_tol,0);
    
    // Output
    //////////////will be generated/////////////////////////////////////////////
    #include "Output.cpp"
    ////////////////////////////////////////////////////////////////////////////
    
    octDA->destroyVector(uSolVec);

    if(!rank)
        std::cout<<" End of computation. "<<std::endl;

    delete octDA;

    MPI_Finalize();
    return 0;
}
